## How to calculate the code is efficient

Faster?

Memory extensive?

Readable?

### Time complexity:

time taken to execute the program

### Space complexity:

space taken to execute the program

## Big O notation:

to analyze the performance of algorithm

To identify the worst case for an algorithm

O(n2) = quadratic
O(n) = linear
O(1) = constants
O(log n)

Omega best case
Theta average case
Big O worst case

O(n2) , O(n), O(1), O(log n)

O(n) is better than O(n2) since it will be executed n times

Drop constants

ie O(2\*n) = O(n)

O(500) =O(1)

O(13n2) = O(n2)

O(n+10) =O(n)

O(n2 + 500 + 8) =O(n2)

O(n2) = n square

O(n3)= n cube

O(n cube) will be treated as O(n2)

O(n square + n) will be treated as O(n square)

### Order of efficient programming

O(1)

O(log n)

O(n)

O(n log n)

O(n2) n square

### Space complexity:

Auxiliary space complexity means the space taken by the algorithm to execute and not the size of the inputs.

## Big O notation for objects and arrays

### Objects

Access : O(1)

Searching: O(n)

Pushing and removing O(1)

### Arrays

Pushing and removing in last O(1)

Pushing and removing in the beginning O(n)

Access: O(1)

Searching: O(n)

Splice, slice O(n)

Foreach, map, filter, reduce O(n)

## Algorithm

Set of steps to solve a task

Understand the problem

1. restate the problem in own words

2. what are the inputs

3. what are the outputs out from the solution

4. do I have enough information to solve the problem
