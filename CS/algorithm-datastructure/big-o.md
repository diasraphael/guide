## How to calculate the code is efficient

Faster?

Memory extensive?

Readable?

### Time complexity:

time taken to execute the program

### Space complexity:

space taken to execute the program

## Big O notation:

to analyze the performance of algorithm

To identify the worst case for an algorithm

O(n2) = quadratic
O(n) = linear
O(1) = constants
O(log n)

Omega best case
Theta average case
Big O worst case

O(n2) , O(n), O(1), O(log n)

O(n) is better than O(n2) since it will be executed n times

Drop constants

ie O(2\*n) = O(n)

O(500) =O(1)

O(13n2) = O(n2)

O(n+10) =O(n)

O(n2 + 500 + 8) =O(n2)

O(n2) = n square

O(n3)= n cube

O(n cube) will be treated as O(n2)

O(n square + n) will be treated as O(n square)

### Order of efficient programming

O(1)

O(log n)

O(n)

O(n log n)

O(n2) n square

### Space complexity:

Auxiliary space complexity means the space taken by the algorithm to execute and not the size of the inputs.

## Big O notation for objects and arrays

### Objects

Access : O(1)

Searching: O(n)

Pushing and removing O(1)

### Arrays

Pushing and removing in last O(1)

Pushing and removing in the beginning O(n)

Access: O(1)

Searching: O(n)

Splice, slice O(n)

Foreach, map, filter, reduce O(n)

## Algorithm

### Set of steps to solve a task(A plan for solving problems)

Understand the problem

1. restate the problem in own words

2. what are the inputs

3. what are the outputs out from the solution

4. do I have enough information to solve the problem

Explore with examples

1. start with simple examples(simple input and output)

2. progress to more complex examples(complex input and output)

3. explore examples with empty inputs

4. explore examples with invalid inputs

Break you code

1. explicitly write out the steps you need to take

2. clarify the doubts

Solve and simplify

1. find the core difficulty in what we are trying to do

2. temporarily ignore that difficulty

3. write a simplified solution

4. then incorporate that difficulty back in.

refactor

1. can you check the result

2. can you derive the result differently

3. can you improve the performance of your solution

4. can you think of other ways to refactor

5. how other people would have solved this problem

### Master common problem solving patterns
